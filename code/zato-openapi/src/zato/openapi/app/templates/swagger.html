<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zato API Documentation</title>
  <link rel="stylesheet" href="/static/swagger-ui/swagger-ui.css" />
  <link rel="icon" type="image/png" href="/static/swagger-ui/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/static/swagger-ui/favicon-16x16.png" sizes="16x16" />
  <link rel="shortcut icon" href="/static/swagger-ui/favicon.ico" />
  <link rel="apple-touch-icon" href="/static/swagger-ui/apple-touch-icon.png" />
  <link rel="manifest" href="/static/swagger-ui/site.webmanifest" />
  <style>
    html {
      box-sizing: border-box;
      overflow: -moz-scrollbars-vertical;
      overflow-y: scroll;
    }
    *, *:before, *:after {
      box-sizing: inherit;
    }
    body {
      margin: 0;
      background: #fafafa;
    }

    /* Custom path search styles */
    #path-search-container {
      padding: 10px 20px;
      background: #fff;
      box-shadow: 0 1px 2px 0 rgba(0,0,0,.15);
      width: 100%;
      max-width: 960px;
      margin: 0 auto 10px auto;
      box-sizing: border-box;
      display: flex;
      align-items: center;
    }

    #path-search-input {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid #d9d9d9;
      border-radius: 4px;
      font-size: 14px;
    }

    #path-search-clear {
      margin-left: 10px;
      cursor: pointer;
      background: #f44336;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
    }

    #path-search-info {
      margin-left: 15px;
      font-size: 12px;
      color: #666;
      min-width: 70px;
      display: inline-block;
      text-align: left;
    }

    /* Hide operations that don't match the search */
    .path-hidden {
      display: none !important;
    }

    /* Highlight matching path parts */
    .path-match {
      background-color: yellow;
      font-weight: bold;
    }

    /* Path numbering styles */
    .path-number {
      position: absolute;
      right: calc(100% + 10px);
      top: 50%;
      transform: translateY(-50%);
      color: #555;
      font-weight: bold;
      font-size: 12px;
      padding: 3px 5px;
      background: rgba(73, 204, 144, 0.1);
      min-width: 30px;        /* Ensure minimum width for the number container */
      text-align: center;     /* Center the numbers */
      white-space: nowrap;    /* Prevent wrapping */
      overflow: visible;      /* Allow overflow */
    }

    /* Schema number styling (different color) */
    .schema-number {
      position: absolute;
      right: calc(100% + 30px);
      top: 50%;
      transform: translateY(-50%);
      font-weight: bold;
      color: #555; /* Restore original color */
      background: rgba(73, 114, 204, 0.1);
      padding: 3px 5px;
      font-size: 12px;
      min-width: 30px;        /* Ensure minimum width for the number container */
      text-align: center;     /* Center the numbers */
      white-space: nowrap;    /* Prevent wrapping */
      overflow: visible;      /* Allow overflow */
      z-index: 10;
    }

    /* Add some extra spacing to operations to accommodate numbers */
    .opblock-summary {
      padding-left: 8px !important; /* Ensure there's always space for the number */
    }
  </style>
</head>
<body>
  <div id="swagger-ui"></div>

  <script src="/static/swagger-ui/swagger-ui-bundle.js" charset="UTF-8"></script>
  <script src="/static/swagger-ui/swagger-ui-standalone-preset.js" charset="UTF-8"></script>
  <script>
    window.onload = function() {
      // Define a custom preset that removes the topbar
      const NoTopbarPreset = function() {
        return {
          components: {
            Topbar: function() { return null }
          }
        }
      }

      // Initialize Swagger UI
      window.ui = SwaggerUIBundle({
        url: "/openapi.yaml",
        dom_id: '#swagger-ui',
        deepLinking: true,
        presets: [
          SwaggerUIBundle.presets.apis,
          NoTopbarPreset
        ],
        layout: "BaseLayout",
        // Add a callback when Swagger UI has finished loading
        onComplete: function() {
          // Initialize our custom path search after Swagger UI loads
          initPathSearch();
          // Add numbering to all paths
          addPathNumbering();
          // Add numbering to schemas
          addSchemaNumbering();
        }
      });

      // Add path numbering to all operations
      function addPathNumbering() {
        // Get all operation blocks
        const operations = document.querySelectorAll('.opblock-summary');
        let pathCounter = 1;
        const totalPaths = operations.length;

        // Calculate number format (padding) based on total number of paths
        const numDigits = totalPaths.toString().length;

        // Add extra margin to the parent container if many digits
        if (numDigits > 2) {
          // Add extra padding to all parent containers
          document.querySelectorAll('.opblock').forEach(block => {
            block.style.marginLeft = (numDigits * 10) + 'px';
          });
        }

        // Add number to each operation
        operations.forEach(operation => {
          // Create number element
          const numberElement = document.createElement('div');
          numberElement.className = 'path-number';

          // Format number with leading zeros for consistent width
          const formattedNumber = pathCounter.toString().padStart(numDigits, ' ');
          numberElement.textContent = formattedNumber;
          pathCounter++;

          // Make sure the operation has position relative
          operation.style.position = 'relative';

          // Add number element to operation
          operation.appendChild(numberElement);
        });
      }

      // Add numbering to schema sections
      function addSchemaNumbering() {
        try {
          // Wait for schemas to fully load before attempting to add numbers
          const waitForSchemas = () => {
            // Clear any existing numbers first
            document.querySelectorAll('.schema-number').forEach(el => el.remove());

            // Target the schema accordion buttons which contain the schema titles
            const schemaAccordions = document.querySelectorAll('.json-schema-2020-12-accordion');
            console.log('Found schema accordions:', schemaAccordions.length);

            if (!schemaAccordions.length) {
              console.log('No schema accordions found, retrying in 1s');
              setTimeout(waitForSchemas, 1000);
              return;
            }

            // Apply the numbering
            let counter = 1;
            const totalSchemas = schemaAccordions.length;
            const numDigits = totalSchemas.toString().length;
            console.log(`Numbering ${totalSchemas} schemas with ${numDigits} digits padding`);

            // For schema elements - use a different zIndex to appear above paths
            document.querySelectorAll('.schema-number').forEach(el => {
              el.style.zIndex = '10';
            });

            // Apply padding to models section if needed
            if (numDigits > 2) {
              const modelsSection = document.querySelector('.models');
              if (modelsSection) {
                modelsSection.style.paddingLeft = (numDigits * 6 + 30) + 'px';
              }
            }

            schemaAccordions.forEach(accordion => {
              // Find the parent article which has a position context
              const article = accordion.closest('article');
              if (!article) return;

              // Set relative positioning on the article
              article.style.position = 'relative';

              // Get title text for logging
              const titleEl = accordion.querySelector('.json-schema-2020-12__title');
              const titleText = titleEl ? titleEl.textContent : 'unknown';

              // Create number element with schema specific style
              const numberElement = document.createElement('div');
              numberElement.className = 'schema-number';

              // Format number with proper padding using spaces
              const formattedNumber = counter.toString().padStart(numDigits, ' ');
              numberElement.textContent = formattedNumber;
              counter++;

              // Don't add additional positioning - let the CSS handle it
              // This ensures schema numbers align with path numbers

              // Append to the article (schema container)
              article.appendChild(numberElement);

              console.log(`Added number ${formattedNumber} to schema: ${titleText}`);
            });
          };

          // Ensure models section is expanded first
          const modelsControl = document.querySelector('.models-control');
          if (modelsControl && modelsControl.getAttribute('aria-expanded') !== 'true') {
            console.log('Expanding models section first');
            modelsControl.click();
          }

          // Start the process with a small delay
          setTimeout(waitForSchemas, 500);
        } catch (error) {
          console.error('Error in schema numbering:', error);
        }
      }

      // Initialize custom path search functionality
      function initPathSearch() {
        // Create and insert the search container after the information-container wrapper
        const infoContainer = document.querySelector('.information-container.wrapper');
        if (!infoContainer) {
          console.error('Could not find .information-container.wrapper');
          return;
        }

        // Create the search container elements
        const searchContainer = document.createElement('div');
        searchContainer.id = 'path-search-container';

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.id = 'path-search-input';
        searchInput.placeholder = 'Search by path (min. 2 characters)';

        const clearButton = document.createElement('button');
        clearButton.id = 'path-search-clear';
        clearButton.textContent = 'Clear';

        const searchInfo = document.createElement('div');
        searchInfo.id = 'path-search-info';

        // Assemble the container
        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearButton);
        searchContainer.appendChild(searchInfo);

        // Insert after the info container
        infoContainer.parentNode.insertBefore(searchContainer, infoContainer.nextSibling);

        // Store original path texts for each operation to avoid corrupting the search
        const operations = document.querySelectorAll('.opblock');
        const pathTexts = new Map();

        operations.forEach(operation => {
          const pathElement = operation.querySelector('.opblock-summary-path, .opblock-summary-path__deprecated');
          if (pathElement) {
            // Store the original path text for this operation
            pathTexts.set(operation, pathElement.textContent);
          }
        });

        let timeoutId = null;

        // Function to perform the actual search with debounce
        function performSearch() {
          const query = searchInput.value.trim().toLowerCase();

          // Only search if at least 2 characters are entered
          if (query.length < 2) {
            resetSearch();
            searchInfo.textContent = '';
            return;
          }

          // Find all operation containers
          let matchCount = 0;

          operations.forEach(operation => {
            // Get the original path text from our map
            const originalPath = pathTexts.get(operation);
            if (!originalPath) return;

            // Find the path element to update its display
            const pathElement = operation.querySelector('.opblock-summary-path, .opblock-summary-path__deprecated');
            if (!pathElement) return;

            // Check if the path contains the search query
            const pathLower = originalPath.toLowerCase();
            if (pathLower.includes(query)) {
              matchCount++;
              operation.classList.remove('path-hidden');

              try {
                // Highlight the matching part of the path
                const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const highlightedText = originalPath.replace(
                  new RegExp(escapedQuery, 'gi'),
                  match => `<span class="path-match">${match}</span>`
                );
                pathElement.innerHTML = highlightedText;
              } catch (e) {
                console.error('Error highlighting path:', e);
                pathElement.textContent = originalPath; // Fallback to plain text
              }
            } else {
              // Hide operations that don't match
              operation.classList.add('path-hidden');
              // Reset to original text without highlights
              pathElement.textContent = originalPath;
            }
          });

          // Expand all matching operations' parents (tags)
          document.querySelectorAll('.opblock:not(.path-hidden)').forEach(operation => {
            const tagItem = operation.closest('.opblock-tag-section');
            if (tagItem) {
              tagItem.classList.remove('is-open');
              tagItem.classList.add('is-open');
            }
          });

          // Update search info
          searchInfo.textContent = `${matchCount} result${matchCount !== 1 ? 's' : ''}`;
        }

        // Function to reset the search and show all operations
        function resetSearch() {
          operations.forEach(operation => {
            operation.classList.remove('path-hidden');
            const pathElement = operation.querySelector('.opblock-summary-path, .opblock-summary-path__deprecated');
            const originalPath = pathTexts.get(operation);

            if (pathElement && originalPath) {
              pathElement.textContent = originalPath; // Restore original text
            }
          });
          searchInfo.textContent = '';
        }

        // Add input event with debounce (for real-time filtering)
        searchInput.addEventListener('input', function() {
          // Clear previous timeout
          if (timeoutId) {
            clearTimeout(timeoutId);
          }

          // Set a small timeout to avoid searching on every keystroke
          timeoutId = setTimeout(performSearch, 200);
        });

        // Add clear button functionality
        clearButton.addEventListener('click', function() {
          searchInput.value = '';
          resetSearch();
        });
      }
    };
  </script>
</body>
</html>
